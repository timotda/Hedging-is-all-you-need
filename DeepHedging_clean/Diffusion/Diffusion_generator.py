import torch
import numpy as np
import pandas as pd
import os
from pathlib import Path

class diffusion_data():
    """
    Data generator for deep hedging models trained on diffusion-simulated price paths. 
    Handles pre-generated stock paths created by diffusion model ( aapl_returns.npy (shape: num_paths, T, num_assets) ) and prepares both training, validation and testing datasets
    """

    def __init__(self, sequence_length, dt, K, S0, idx_assets_to_hedge):
        """
        Args:
            - sequence_length (int): Length of each price path (T)
            - dt (int): Time step size
            - simulated_paths: Pre-simulated paths array (num_paths, T, num_assets) or DataFrame
            - K (int): Strike price
            - S0 (int) : Initial stock price
            - idx_assets_to_hedge (list) : List of asset indices to use for hedging
        """
        self.sequence_length = sequence_length
        self.dt = dt 
        self.T = self.sequence_length * self.dt
        self.K = K
        self.S0 = S0
        self.idx_assets_to_hedge = idx_assets_to_hedge

    def build_data(self):
        """
        Build training and test data from pre-simulated paths stored as .npy files generated by our diffusion model
        Only loads the asssets specified by self.idx_assets_to_hedge for efficiency
        Returns : 
            - simulated_paths (np.array) : shape == (num_paths, T, num_hedging_assets) :  normalized price paths.
        """
    
 
        # Define asset mapping (index -> asset name)
        asset_names = ['AAPL', 'GOOGL', 'MSFT', 'AMZN', 'BRK-B']
        
        # Get the data directory path relative to this file
        current_dir = Path(__file__).parent
        data_dir = current_dir.parent / 'Data'
        
        # Only load the assets we need based on idx_assets_to_hedge
        loaded_assets = []
        for idx in self.idx_assets_to_hedge:
            asset_name = asset_names[idx]
            file_path = data_dir / f"{asset_name}_returns.npy"
            loaded_assets.append(np.load(file_path))
        
        # Stack arrays to create (num_paths, T, num_hedging_assets) structure
        simulated_paths = np.stack(loaded_assets, axis=-1)
        
    
        if simulated_paths.ndim == 4:
            simulated_paths = simulated_paths.squeeze(axis=2)

        return simulated_paths #simulated_paths_scaled
    
    def make_test_data(self):
        """
        Extracts the last 30% of historical storck prices
        Computes log returns from real prices
        Creates rolling windows of length = sequence_length
        Normalizes each window to start at S_0
        Args : None
        Returns:
            - prices_test (np.array) : shape == (num_windows, T, N) : price paths
            - returns_test (np.array) : shape == (num_windows, T, N) : returns paths
        """
        # Get the data directory path relative to this file
        current_dir = Path(__file__).parent
        data_dir = current_dir.parent / 'Data'
        
        stock_prices = pd.read_csv(data_dir / 'stocks_close_prices_2008_2025.csv')
        stock_prices.set_index('Date', inplace=True)
        
        asset_prices = stock_prices.iloc[:, self.idx_assets_to_hedge]
        
        split = int(0.7 * len(asset_prices))
        test_asset_prices  = asset_prices.iloc[split:]

        test_returns  = np.log(test_asset_prices  / test_asset_prices.shift(1)).dropna()
       
        test_returns = test_returns.values
        test_prices = test_asset_prices.iloc[1:].values  # align with returns
        
  
        T = self.sequence_length
        price_windows  = []
        return_windows = []
        
        num_samples = len(test_returns) - T  # because need T returns AND T+1 prices
        for start in range(num_samples):
            end_r = start + T          # returns: [start, ..., start+T-1]
            end_p = start + T+1          # prices : [start, ..., start+T]

            R_window = test_returns[start:end_r]      # (T, N)
            S_window = test_prices[start:end_p]      # (T+1, N)

            S_norm = S_window / S_window[0] * self.S0

            price_windows.append(S_norm)
            return_windows.append(R_window)
        

        prices_test  = np.stack(price_windows, axis=0)
        returns_test = np.stack(return_windows, axis=0)

        return prices_test, returns_test

    def make_val_data(self):
        """
        Exact same function as make_test_data but on the validation split
        """
        # Get the data directory path relative to this file
        current_dir = Path(__file__).parent
        data_dir = current_dir.parent / 'Data'
        
        stock_prices = pd.read_csv(data_dir / 'stocks_close_prices_2008_2025.csv')
        stock_prices.set_index('Date', inplace=True)
        
        asset_prices = stock_prices.iloc[:, self.idx_assets_to_hedge]
        
        # valdiation data is the first 20% of the testing dataset
        split = int(0.7 * len(asset_prices))
        testing_asset_prices = asset_prices.iloc[split:]
        val_asset_prices = testing_asset_prices.iloc[:int(0.2*testing_asset_prices.shape[0]), :]

        val_returns = np.log(val_asset_prices / val_asset_prices.shift(1)).dropna()
        val_returns = val_returns.values 
        val_prices = val_asset_prices.iloc[1:].values  # align with returns

  
        T = self.sequence_length
        price_windows  = []
        return_windows = []
        
        num_samples = len(val_returns) - T  # because need T returns AND T+1 prices
        for start in range(num_samples):
            end_r = start + T          # returns: [start, ..., start+T-1]
            end_p = start + T+1          # prices : [start, ..., start+T]

            R_window = val_returns[start:end_r]      # (T, N)
            S_window = val_prices[start:end_p]      # (T+1, N)

            S_norm = S_window / S_window[0] * self.S0

            price_windows.append(S_norm)
            return_windows.append(R_window)
        

        prices_val  = np.stack(price_windows, axis=0)
        returns_val = np.stack(return_windows, axis=0)

        return prices_val, returns_val